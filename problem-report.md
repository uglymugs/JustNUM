# Problem Report

We hope that future developers will find it easy to get up to speed with our app, as we have followed the guidelines for good practice set out by Dan Abramov in his Redux videos and exemplified by the minimal repo [here](https://github.com/gaearon/todos).

There are nonetheless various corners and complexities that may not be immediately obvious. To aid in understanding these, we are building a record of the technical problems that we encountered on this project and the solutions that we found.

At the moment the report is very much *in progress...*

#### Deployd Boolean Fields

###### Problem

Submitting a form to the database was returning a generic error even though form data was good.

###### Solution

Deployd debug logs (turn them on with `export DEBUG="*"`) revealed validation on the backend was failing on certain boolean fields. The fields were set to `isRequired` and Deployd was failing to distinguish between values of `false` and `null` or `undefined`. The workaround was to remove `isRequired` for these fields--if they are missing Deployd sets them to false anyway.

#### Deployd Dashboard Key

###### Problem

This is easy to get from the local command line but what about when the app is hosted remotely?

###### Solution

Run `dpd keygen && dpd showkey && npm start` from the Procfile and get the key from Heroku log.

#### Hash History Querystring

###### Problem

`hashHistory` from React-router puts a querystring starting `_k=` after every url. This is ugly and causes issues with navigation using the address bar; for example, hitting refresh will incorporate the querystring into the `path` recognised by React-router.

###### Solution

It is possible to manually create a hash history object without a query string and pass it to React-router. This only works if you use the same version of `history` as React-router:

```jsx
import { Router, useRouterHistory } from 'react-router';
import { createHashHistory } from 'history';

const appHistory = useRouterHistory(createHashHistory)({ queryKey: false });

<Router history={appHistory}>
```

Be aware that the querystring is used by `hashHistory` to access any state you set for your locations like this:

```jsx
router.push('/home', { some: 'state' })
```

We do not use location state, so removing the querystring is fine.

This may not be an issue with React-router v.3 (still alpha). See [here](https://github.com/ReactTraining/react-router/issues/1967).

#### Tasks Form List

###### Problem

Tasks would would appear to be randomly missing from the list of editable tasks beneath the case form. This was noticeable when switching between 'all' and 'pending' or 'to do' on the filter. 

###### Solution

When multiple components are generated by a loop as an array, React uses a ´key´ prop to keep track of which components inside the array get added, removed or changed. We were setting this prop by the index of the element in the mapped array, a practice that React docs suggest is [acceptable, if non-optimal](https://facebook.github.io/react/docs/lists-and-keys.html), since without a 1:1 correspondence between data and key React cannot optimise the diff. 

```jsx
{tasks.map((task, idx) =>
      <ConnectedEditTaskForm key={idx} task={task} />)}
```

In fact, setting the key from the index can break the rerender entirely. Here's why (I think): if we apply a filter that selects items 3 and 4 from the list, their keys will be changed to 0 and 1. React will not rerender the components that already have those keys -- i.e. items 1 and 2 on the list. But we have filtered out their data on the props so we will get empty components...

The solution was to use the unique id from the database:

```jsx
{tasks.map((task) =>
      <ConnectedEditTaskForm key={task.id} task={task} />)}
```

#### Storing Dates

###### Problem

Deployd does not offer a date data type.

###### Solution

We convert dates to UTC milliseconds for storage in the database. Conversion is done with `moment`. Currently these conversions are defined independently in various components (case list, task tabs and task forms) -- it would be better to extract date conversion functions and import them where needed.

#### Abstracting 'Create' Forms and 'Edit' Forms

###### Problem

The forms that are used to create a case or task and edit a case or task are almost identical. But what is the best way to extract the common functionality?

###### Solution

We implemented the case form before the task form. Operating on the principle that something should work before it is refactored, we have extracted a common form for cases, but did not get onto doing the same for tasks. The way in which we did it is somewhat problematic.

#### Populating components asynchronously

###### Problem

There are several places where the data for components is obtained by an asynchronous API call. How do we get the data into a component after it is rendered?

###### Solution

Two possibilities we rejected were:

1. Dispatching the action inside the `onClick` handler of the link used to navigate to the component.
2. Dispatching it inside the `onEnter` handler on React-router's routes.

Since we wanted users to be able to navigate to components from the address bar we discounted the first option. The second option is criticised [here](https://github.com/ReactTraining/react-router/issues/1389) on the basis that the route transition will be blocked until the data is received.

We dispatch an action inside `componentDidMount`. Unfortunately this solution means our component is no longer purely functional. In some cases we have extracted the API call into a class which does nothing else but wrap the component to be populated, which mitigates the problem of side effects. If continuing with this solution, it would probably be a good idea to extract this functionality further into a single higher order component that takes a dispatcher and can be used to wrap anything.

In retrospect, though, I see no problem with dispatching an action in `onEnter`. The transition will not be blocked unless the callback is deliberately delayed. The component will render without data and redux will populate it when the data arrives, which is the same effect as firing the action in `componentDidMount`. Something like this would do the trick:

```jsx
const load = ({dispatch}) =>
	(nextState, replace) => { // no need to pass the callback
      dispatch(asyncAction)
    }
<Route path='path' component={comp} onEnter={load(store)} />
```


